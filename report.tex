\documentclass[9pt,twocolumn]{article}

% Set margins
\usepackage[margin=0.5in]{geometry}
\setlength{\columnsep}{.5in}
% Set fonts, both for main and for source code
\usepackage{fontspec}
\setmainfont{"[times_new_roman.ttf]"}
\setmonofont{"[inconsolata.ttf]"}

% formatting for source code
\usepackage{listings}
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
  backgroundcolor=\color{white},   % choose the background color; you must add
                                   % \usepackage{color} or \usepackage{xcolor}
  basicstyle=\ttfamily,            % the size of the fonts that are used for
                                   % the code
  breakatwhitespace=false,         % sets if automatic breaks should only
                                   % happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  columns=fullflexible,            % make it wrap columns at max possible
  deletekeywords={...},            % if you want to delete keywords from the
                                   % given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for
                                   % 8-bits encodings only, does not work with
                                   % UTF-8
  frame=none,                      % adds a frame around the code, none, single
  keepspaces=true,                 % keeps spaces in text, useful for keeping
                                   % indentation of code (possibly needs
                                   % columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=C,                      % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the
                                   % set
  numbers=none,                    % where to put the line-numbers; possible
                                   % values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\color{mygray},      % the style that is used for the
                                   % line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed
                                   % on line-breaks within not-black text (e.g.
                                   % comments (green here))
  showspaces=false,                % show spaces everywhere adding particular
                                   % underscores; it overrides
                                   % 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular
                                   % underscores
  stepnumber=1,                    % the step between two line-numbers. If it's
                                   % 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with
                                   % \lstinputlisting; also try caption instead
                                   % of title
}


\newcommand{\NumPackages}{85 }
\newcommand{\NumPatches}{18 }
\newcommand{\NumPatchesAccepted}{6 }


\title{Uncovering Undefined Behavior}
\usepackage{hyperref}
\author{
    Eric Lubin\\
    \href{mailto:eblubin@mit.edu}{eblubin@mit.edu}
\and
    Nick Anaya\\
    \href{mailto:nanaya@mit.edu}{nanaya@mit.edu}
}

\begin{document}
\maketitle

\section{Overview}
In this project we study the effects of undefined behavior in open source software
and its ability to cause unstable code to be optimized out by modern compilers.

Given the sheer number of software systems that contain such errors, 
with about 50\% of Debian packages reporting over 80,000 different warnings,
we attempted to begin the process of filtering through these results. 

With the help of STACK\cite{stack}, we analyzed \NumPackages packages, 
from Debian and other locations, and submitted a total of \NumPatches patches, 
of which \NumPatchesAccepted have been accepted thus far, with the rest pending approval.
This paper presents a case study into the common mis-practices of many developers and
has helped us develop a rule-of-humb heuristic as to which types of bugs are more
or less likely to be vulnerabilities.

In section~\ref{sec:threat} we review the threat model, in section~\ref{sec:classification}
we break down the observed bugs into a number of different categories that loosely 
correspond to the the types of bugs STACK can detect, and in section~\ref{sec:conclusion}
we wrap up and discuss future areas of research. Finally, section~\ref{sec:appendix} provides an 
appendix of all patches found and submitted thus far.

\section{Threat Model}
\label{sec:threat}
We assume that an attacker has complete knowledge of the source code in question. Any 
optimization unsafe bugs that exist they are able to find and exploit if there is any entry point.

\section{Classification of Unstable Code}
\label{sec:classification}
Generally, the bugs we found due to unstable code fell into several
main categories. First, null pointer dereferences were the  most common type of 
bug signaled by STACK but did not alter correctness. Mixed in with these null pointer dereferences
were actual programmer errors due to accidentally not dereferencing pointers for which
they wanted their value. Second, signed integer operation overflow checks were another common source
of developer misconception. Thirdly, there were pointer overflow bugs. And finally, there were a class
of miscellaneous bugs related to division by zero, buffer overflow by one, and shift left and right overflow.


\subsection{Null Pointer Dereference}
Null pointer dereference, caused by checks to ensure that pointer is not null,
but pointer is never not null at location. True result optimized out.

\subsection{Signed Integer Operation Overflow}
According to the C standard, the overflow of signed integers results in undefined behavior. This standard allows the compiler to make various sorts of optimizations that it wouldn't normally have been able to make because it assumes signed integer arithmetic cannot overflow. We found that many developers incorrectly go out of their way to try to catch these overflows. Instead of using constants like \texttt{INT\_MAX}, they assume that an overflow will wrap around to its negative value and check to see if the sume is less than one of the operands. Unfortunately, if they were to check this with DEBUG on and no optimizations, it would probably work, leading to a greater misunderstanding among developers about how to correctly check if an signed operation will overflow.

\subsubsection{Exploiting libcurl}
In the following example, we see an instance of incorrect signed integer overflow and its subsequent security implications for cURL's \texttt{curl\_parsedate}. In figure~\ref{fig:libcurl1} we see a function that is public to the API for computing the time stamp associated with a given string representation of the date. First, the code parses the date string up to everything but the time zone difference and stores the result into a \texttt{t} of type \texttt{time\_t}. Next, it validates that the time zone is one of many available timezones specified in the header file, or if not that it is within 14 hours ahead or behind of GMT. The developer then is aware of the fact that adding the offset to the original time might overflow the time, Unfortunately, seemingly unaware of the distinction between signed-type overflows and how they are not guaranteed to wrap around in the same way as their unsigned integer counting parts, the developer implements these overflow checks incorretly. The compiler, on sufficiently high optimization levels, takes advantage of the fact that signed types cannot overflow and then assumes that the addition will not converge.With this optimization, checks like $y + 250 < y$ gets simplified to false, thereby bypassing the extra security checks that the developer put in for the whole sake of limiting bugs.

\begin{figure}[h]
\begin{lstlisting}
time_t t = ...;
/* Add the time zone diff between local time zone and GMT. */
long delta = (long)(tzoff!=-1?tzoff:0);
 
if((delta>0) && (t + delta < t))
    return -1; /* time_t overflow */
 
t += delta;
\end{lstlisting}
\label{fig:libcurl1}
\caption{The above shows an unstable signed integer check for overflow. The developer has gone out of this way to right this check, but is mistaken as to the accepted behavior of signed integers on overflow, which is undefined. The compiler then simplifies $ t  + $ delta $ < t$ to delta $ < 0$ and thus the compound expression evaluates to false. There is a potential overflow in incrementing \texttt{t} by \texttt{delta}, which is never checked because the compiler has optimized out the unstable code, and this overflow propagates outwards to any library calling this function without any chance of recovery.}
\end{figure}


In response, we wrote a simple exploit that seeks to take advantage of the bug by overflowing \texttt{t} due to the time zone difference. We assumed for the sake of simplicity that we were working on a 32 bit machine so that our exploit date string was a small date, but if we were on a 64 bit machine the exploit would work the same just the date would have to about 290 billion years later. Our exploit, shown in~\ref{fig:curl-xploit}, passes in to the \texttt{parsedate} function a string that represents the maximum representable timestamp with a signed 32 bit integer: 03:14:07 UTC on Tuesday, 19 January 2038. We then append to this a timezone string such as "-0200." When the code path is executed, $t$ is \texttt{INT\_MAX} and then 20*60*60 is added to it, which overflows. Since the compiler optimized out the overflow check, this undefined value can propagate outwards to any callers of this of this library function and potentially have security implications for them as well.

\begin{figure}[h]
\begin{lstlisting}
char   *exploit = "19 Jan 2038  03:14:07 -0200";
time_t time = curl_getdate(exploit, NULL);
\end{lstlisting}
\label{fig:curl-xploit}
\caption{The above shows a working exploit for the \texttt{curl\_parsedate} bug. Taking advantage of the undefined behavior of signed integer overflow, the overflow goes undetected due to the unstable code check. }
\end{figure}

To patch this bug, we check instead for overfow by checking for \texttt{t < INT\_MAX - delta}, which fixes the bug and successfully anticipates the overflow before it happens, because once it happens it is too late.



\subsection{Programmer Error}

\subsection{Argument Checking}

Order of positions matter, can cause overflow if in wrong order. Accessing out of bounds memory, shifting right and left



\section{Conclusion}
\label{sec:conclusion}
Overall, we have shown the value that STACK brings to the suite of static checkers available to 
developers to verify the correctness and stability of their code. STACK can even present warnings
to the developer that catch simple careless error where certain pointers are not dereferenced, as
was the case with Subversion and Audacity. 

Nonetheless, we have noticed the difficulty with discovering legitimate exploits based on these
undefined behavior bugs. Amidst countless redundant null pointer dereferences, many such bugs
are hidden numerous levels deep from the outwards facing components in these packages. As a result,
the ability to propagate an invalid input into such a bug and then exploit this bug is highly challenging. 

In the future, we hope to take this research further. In particular, we'd like to analyze more large
scale packages such as the llvm, julia, and latex packages. Given the time and processor constraints
of this project and the slight difficulty we had in compiling llvm in the first place for using
with stack, we would like to be able to devote more time into such an endeavor. Furthermore, while we liked
having access to all the Debian packages having already been analyzed by STACK, we spent a lot of our time
building other packages andsuppressing compiler warnings instead of analyzing pstack reports. 
In the past week, we have discussed writing a harness into \texttt{brew install} in order to get STACK
results on a much larger variety of packages. Furthermore, we want to focus on existing bugs to attempt
to continue on our quest for exploitable, public facing bugs..

\bibliographystyle{plain}
\bibliography{report}
\section{Appendix}
\label{sec:appendix}
\end{document}
